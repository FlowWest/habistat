---
title: "Predictor Data Preparation and Consolidation"
author: "[Skyler Lewis](mailto:slewis@flowwest.com)"
date: "`r Sys.Date()`"
output: 
  github_document:
    toc: true
    toc_depth: 3
    number_sections: false
    math_method:
      engine: webtex
      url: https://latex.codecogs.com/svg.image?
---

```{r setup}
library(tidyverse)
library(sf)
library(habistat)
library(patchwork)
theme_set(theme_minimal())
```

## Basic Flow Crosswalk via Drainage Area and Precipitation

See watershed_delineation.R for dependencies

```{r multipliers}
make_flow_xw <- function(group_var) {
  habistat::flowline_attr |>
  select({{group_var}}, 
         comid = comid,
         da_reach = da_area_sq_km_tot,
         pc_reach = da_ppt_mean_mm) |>
  drop_na({{group_var}}) |>
  group_by({{group_var}}) |>
  mutate(outlet_comid = comid[which.max(da_reach)]) |>
  mutate(da_outlet = da_reach[which(comid == outlet_comid)],
         pc_outlet = pc_reach[which(comid == outlet_comid)]) |>
  mutate(multiplier = (da_reach / da_outlet) * (pc_reach / pc_outlet)) |>
  arrange({{group_var}}, -multiplier)
}

cv_watersheds_flow_xw <- make_flow_xw(watershed_level_3)
cv_watersheds_flow_xw |> usethis::use_data(overwrite=T)

cv_mainstems_flow_xw <- make_flow_xw(river_cvpia)
cv_mainstems_flow_xw |> usethis::use_data(overwrite=T)

cv_mainstem_groups_flow_xw <- make_flow_xw(river_group)
cv_mainstem_groups_flow_xw |> usethis::use_data(overwrite=T)

habistat::flowline_geom_proj |>
  inner_join(cv_watersheds_flow_xw, by=join_by(comid)) |>
  filter(comid %in% habistat::wua_predicted$comid) |>
  ggplot() + 
  geom_sf(aes(color = multiplier)) + 
  geom_sf(data = habistat::flowline_geom_proj |> 
            filter(comid %in% cv_watersheds_flow_xw$outlet_comid) |> 
            st_line_sample(sample=1), 
          aes(color = 1)) + 
  scale_color_viridis_c(direction = -1) +
  ggtitle("Flow Multipliers by Watershed")

habistat::flowline_geom_proj |>
  inner_join(cv_mainstems_flow_xw, by=join_by(comid)) |>
  filter(comid %in% habistat::wua_predicted$comid) |>
  ggplot() + 
  geom_sf(aes(color = multiplier)) + 
  geom_sf(data = habistat::flowline_geom_proj |> 
            filter(comid %in% cv_mainstems_flow_xw$outlet_comid) |> 
            st_line_sample(sample=1), 
          aes(color = 1)) + 
  scale_color_viridis_c(direction = -1) + 
  ggtitle("Flow Multipliers by Mainstem")

habistat::flowline_geom_proj |>
  inner_join(cv_mainstem_groups_flow_xw, by=join_by(comid)) |>
  filter(comid %in% habistat::wua_predicted$comid) |>
  ggplot() + 
  geom_sf(aes(color = multiplier)) + 
  geom_sf(data = habistat::flowline_geom_proj |> 
            filter(comid %in% cv_mainstem_groups_flow_xw$outlet_comid) |> 
            st_line_sample(sample=1), 
          aes(color = 1)) + 
  scale_color_viridis_c(direction = -1) + 
  ggtitle("Flow Multipliers by Mainstem Group")
```

### Applying the crosswalk to aggregate model results

```{r}
# habistat::wua_predicted <-
#     readRDS(here::here("data-raw", "results", "habistat::wua_predicted.Rds"))
# for backwards compatibility because habistat::wua_predicted is now pivoted

# load(here::here("data", "wua_predicted.Rda")) # this contains the ensemble predictions

wua_predicted_cv_watersheds <- 
  habistat::wua_predicted |>
  inner_join(cv_watersheds_flow_xw, 
             by=join_by(watershed_level_3, comid)) |>
  expand_grid(scaled = c(FALSE, TRUE)) |>
  mutate(flow_cfs = if_else(scaled, flow_cfs * multiplier, flow_cfs)) |>
  arrange(habitat, comid, flow_cfs) |> # , model_name, 
  group_by(habitat, comid) |> # , model_name, 
  mutate(across(c(wua_per_lf_pred, wua_per_lf_pred_SD, wua_per_lf_pred_SN),
                \(v) if_else(scaled, NA, v))) |>
  mutate(across(c(wua_per_lf_pred, wua_per_lf_pred_SD, wua_per_lf_pred_SN),
                \(v) zoo::na.approx(v, x = flow_cfs, na.rm=F, rule=2))) |>
  filter(scaled) |>
  select(-scaled) |>
  ungroup() |>
  group_by(habitat, watershed_level_3, flow_idx) |> # , model_name, 
  summarize(wua_per_lf_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_per_lf_pred_SD = sum(wua_per_lf_pred_SD * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_per_lf_pred_SN = sum(wua_per_lf_pred_SN * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_acres_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / 43560, 
            wua_acres_pred_SD = sum(wua_per_lf_pred_SD * reach_length_ft, na.rm=T) / 43560, 
            wua_acres_pred_SN = sum(wua_per_lf_pred_SN * reach_length_ft, na.rm=T) / 43560, 
            .groups="drop") |>
  inner_join(habistat::wua_predicted |> 
               group_by(flow_idx) |> 
               summarize(flow_cfs = first(flow_cfs), .groups="drop"),
             by = join_by(flow_idx))

# wua_predicted_cv_watersheds <- wua_predicted_cv_watersheds |>
#   pivot_wider(names_from = model_name, values_from = c(wua_per_lf_pred, wua_acres_pred)) |>
#   mutate(wua_per_lf_pred = (wua_per_lf_pred_SD + wua_per_lf_pred_SN) / 2,
#          wua_acres_pred = (wua_acres_pred_SD + wua_acres_pred_SN) / 2)

wua_predicted_cv_watersheds |> usethis::use_data(overwrite=T)

wua_predicted_cv_mainstems <- 
  habistat::wua_predicted |> 
  inner_join(cv_mainstems_flow_xw, 
             by=join_by(river_cvpia, comid)) |>
  expand_grid(scaled = c(FALSE, TRUE)) |>
  mutate(flow_cfs = if_else(scaled, flow_cfs * multiplier, flow_cfs)) |>
  arrange(habitat, comid, flow_cfs) |> # , model_name, 
  group_by(habitat, comid) |>  # , model_name, 
  mutate(across(c(wua_per_lf_pred, wua_per_lf_pred_SD, wua_per_lf_pred_SN),
                \(v) if_else(scaled, NA, v))) |>
  mutate(across(c(wua_per_lf_pred, wua_per_lf_pred_SD, wua_per_lf_pred_SN),
                \(v) zoo::na.approx(v, x = flow_cfs, na.rm=F, rule=2))) |>
  filter(scaled) |>
  select(-scaled) |>
  ungroup() |>
  group_by(habitat, river_cvpia, flow_idx) |> # , model_name, 
  summarize(wua_per_lf_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_per_lf_pred_SD = sum(wua_per_lf_pred_SD * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_per_lf_pred_SN = sum(wua_per_lf_pred_SN * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_acres_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / 43560, 
            wua_acres_pred_SD = sum(wua_per_lf_pred_SD * reach_length_ft, na.rm=T) / 43560, 
            wua_acres_pred_SN = sum(wua_per_lf_pred_SN * reach_length_ft, na.rm=T) / 43560, 
            .groups="drop") |>
  inner_join(habistat::wua_predicted |> 
               group_by(flow_idx) |> 
               summarize(flow_cfs = first(flow_cfs), .groups="drop"),
             by = join_by(flow_idx)) 

# wua_predicted_cv_mainstems <- wua_predicted_cv_mainstems |>
#   pivot_wider(names_from = model_name, values_from = c(wua_per_lf_pred, wua_acres_pred)) |>
#   mutate(wua_per_lf_pred = (wua_per_lf_pred_SD + wua_per_lf_pred_SN) / 2,
#          wua_acres_pred = (wua_acres_pred_SD + wua_acres_pred_SN) / 2)

wua_predicted_cv_mainstems |> usethis::use_data(overwrite=T)

# these are the mainstems grouped for CVPIA model comparison
wua_predicted_cv_mainstems_grouped <- 
  habistat::wua_predicted |> 
  inner_join(cv_mainstem_groups_flow_xw, 
             by=join_by(river_group, comid)) |>
  expand_grid(scaled = c(FALSE, TRUE)) |>
  mutate(flow_cfs = if_else(scaled, flow_cfs * multiplier, flow_cfs)) |>
  arrange(habitat, comid, flow_cfs) |> # , model_name, 
  group_by(habitat, comid) |> # , model_name, 
  mutate(across(c(wua_per_lf_pred, wua_per_lf_pred_SD, wua_per_lf_pred_SN),
                \(v) if_else(scaled, NA, v))) |>
  mutate(across(c(wua_per_lf_pred, wua_per_lf_pred_SD, wua_per_lf_pred_SN),
                \(v) zoo::na.approx(v, x = flow_cfs, na.rm=F, rule=2))) |>
  filter(scaled) |>
  select(-scaled) |>
  ungroup() |>
  group_by(habitat, river_group, flow_idx) |>  # , model_name, 
  summarize(wua_per_lf_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_per_lf_pred_SD = sum(wua_per_lf_pred_SD * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_per_lf_pred_SN = sum(wua_per_lf_pred_SN * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_acres_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / 43560, 
            wua_acres_pred_SD = sum(wua_per_lf_pred_SD * reach_length_ft, na.rm=T) / 43560, 
            wua_acres_pred_SN = sum(wua_per_lf_pred_SN * reach_length_ft, na.rm=T) / 43560, 
            .groups="drop") |>
  inner_join(habistat::wua_predicted |> 
               group_by(flow_idx) |> 
               summarize(flow_cfs = first(flow_cfs), .groups="drop"),
             by = join_by(flow_idx))

# wua_predicted_cv_mainstems_grouped <- wua_predicted_cv_mainstems_grouped |>
#   pivot_wider(names_from = model_name, values_from = c(wua_per_lf_pred, wua_acres_pred)) |>
#   mutate(wua_per_lf_pred = (wua_per_lf_pred_SD + wua_per_lf_pred_SN) / 2,
#          wua_acres_pred = (wua_acres_pred_SD + wua_acres_pred_SN) / 2)

wua_predicted_cv_mainstems_grouped |> usethis::use_data(overwrite=T)
```

Plotting the output

```{r pred-watersheds-new, fig.width=8.5, fig.height=8.5, dpi=300}
wua_predicted_cv_watersheds |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~watershed_level_3, scales="free") + 
  geom_ribbon(aes(ymin = wua_acres_pred_SD, ymax = wua_acres_pred_SN, fill = habitat), alpha=0.33) +
  geom_line(aes(y = wua_acres_pred, color = habitat)) +
  scale_x_log10() +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  ylab("Predicted Total Habitat (acres)") + xlab("Flow at Outlet (cfs)") + 
  ggtitle("Watersheds (incl. tributaries)")

wua_predicted_cv_mainstems |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_cvpia, scales="free") + 
  geom_ribbon(aes(ymin = wua_acres_pred_SD, ymax = wua_acres_pred_SN, fill = habitat), alpha=0.33) +
  geom_line(aes(y = wua_acres_pred, color = habitat)) +
  scale_x_log10() +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  ylab("Predicted Total Habitat (acres)") + xlab("Flow at Outlet (cfs)") + 
  ggtitle("Mainstems")

wua_predicted_cv_mainstems_grouped |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_group, scales="free") + 
  geom_ribbon(aes(ymin = wua_acres_pred_SD, ymax = wua_acres_pred_SN, fill = habitat), alpha=0.33) +
  geom_line(aes(y = wua_acres_pred, color = habitat)) +
  scale_x_log10() +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  ylab("Predicted Total Habitat (acres)") + xlab("Flow at Outlet (cfs)") + 
  ggtitle("Mainstems (grouped by watershed)")
```

Versus the "naive" method

```{r pred-watersheds-old, fig.width=8.5, fig.height=8.5, dpi=300}
wua_predicted |>
  filter(!is.na(river_group)) |>
  group_by(habitat, river_group, flow_idx, flow_cfs) |>
  summarize(wua_per_lf_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / sum(reach_length_ft, na.rm=T),
            wua_acres_pred = sum(wua_per_lf_pred * reach_length_ft, na.rm=T) / 43560, .groups="drop") |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_group, scales="free") + 
  geom_line(aes(y = wua_acres_pred, color = habitat)) +
  scale_x_log10() +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  ylab("Predicted Total Habitat (acres)") + xlab("Flow (cfs)") +
  ggtitle("Example incorrect method of aggregating - do not use")
```

## DSMHabitat Comparison

Moved this over from model_cleaned.Rmd

```{r dsmhabitat-prep, fig.width=6.5, fig.height=6.5, dpi=300}
mainstems_comid <- 
  read_sf(file.path("/vsizip", here::here("data-raw", "source", "rearing_spatial_data", "nhdplusv2_comid_habitat_xw.shp.zip"))) |>
  janitor::clean_names() |>
  st_zm() |>
  st_transform(st_crs(habistat::flowline_geom_proj)) |>
  mutate(length_ft = st_length(geometry) |> units::set_units("ft") |> units::drop_units()) |>
  filter(str_detect(habitat, "rearing")) |>
  left_join(habistat::flowline_attr |> 
              select(comid, hqt_gradient_class, river_group), by=join_by(comid)) |>
  filter(!(watershed %in% c("Sacramento River", "San Joaquin River")))

mainstems <-
  mainstems_comid |>
  group_by(watershed, river, hqt_gradient_class) |>
  summarize() 

mainstems_comid |> 
  ggplot() + 
  geom_sf(aes(group=river, color=hqt_gradient_class)) + 
  theme(legend.key.height = unit(12, "point")) +
  ggtitle("DSMhabitat reaches")
```

```{r dsmhabitat-join, fig.width=6.5, fig.height=6.5, dpi=300}
# http://cvpia-habitat-docs-markdown.s3-website-us-west-2.amazonaws.com/watershed/Regional_Approximation.html
# These are the watersheds that use regional approximation for *instream* habitat
regional_approx_groups <- 
  c("Antelope Creek", "Bear Creek", "Big Chico Creek", "Cow Creek",
    "Elder Creek", "Mill Creek", "Paynes Creek", "Stony Creek", "Thomes Creek")
# These are the watersheds that use scaled proxies for floodplain habitat
deer_creek_fp_proxy <-
  c("Antelope Creek", "Bear Creek", "Big Chico Creek", "Cow Creek",
    "Mill Creek", "Paynes Creek") 
cottonwood_creek_fp_proxy <- c("Stony Creek", "Thomes Creek")

#remotes::install_github("CVPIA-OSC/DSMhabitat")
watersheds <- mainstems |> pull(watershed) |> unique()
watershed_name <- tolower(gsub(pattern = "-| ", replacement = "_", x = watersheds))
watershed_rda_name <- paste(watershed_name, "floodplain", sep = "_")

dsm_habitat_floodplain <- map_df(watershed_rda_name, function(watershed) {
  df <- as.data.frame(do.call(`::`, list(pkg = "DSMhabitat", name = watershed)))
}) |> 
  select(river_group = watershed,
         flow_cfs,
         ends_with("_floodplain_acres")) |>
  pivot_longer(cols = ends_with("_floodplain_acres"), 
               names_transform = \(x) str_replace(x, "_floodplain_acres", ""),
               names_to = "run",
               values_to = "floodplain_acres") |>
  mutate(run = run |> factor(levels = c("FR", "LFR", "WR", "SR", "ST"),
                             labels = c("fall", "late fall", "winter", "spring", "steelhead")),
         hab = "floodplain" |> factor(levels = c("spawn", "fry", "juv", "adult", "floodplain")),
         floodplain_acres_suitable = DSMhabitat::apply_suitability(floodplain_acres * 4046.86) / 4046.86)
  
dsm_habitat_instream <- map_df(paste(watershed_name, "instream", sep = "_"), 
                               possibly(function(watershed) {
                                 df <- as.data.frame(do.call(`::`, list(pkg = "DSMhabitat", name = watershed)))
                                 }, otherwise = NULL)) |> 
  select(river_group = watershed,
         flow_cfs,
         ends_with("_wua")) |>
  pivot_longer(cols = ends_with("_wua"), 
               names_transform = \(x) str_replace(x, "_wua", ""),
               names_to = "run_hab",
               values_to = "wua_per_1000ft") |>
  separate_wider_delim(run_hab, names = c("run", "hab"), delim = "_") |>
  mutate(wua_per_lf = wua_per_1000ft / 1000,
         run = run |> factor(levels = c("FR", "LFR", "WR", "SR", "ST"),
                             labels = c("fall", "late fall", "winter", "spring", "steelhead")), 
         # TODO: use "labels" to align these with habistat names like "fall" instead of "FR"
         hab = hab |> factor(levels = c("spawn", "fry", "juv", "adult", "floodplain"))) |>
  drop_na() |>
  select(-wua_per_1000ft)

# flow ranges

dsm_flows <- bind_rows(dsm_habitat_floodplain, dsm_habitat_instream) |>
  group_by(river_group, flow_cfs) |>
  summarize() |>
  ungroup() |>
  arrange(river_group, flow_cfs)

dsm_flow_ranges <- 
  dsm_flows |> 
  group_by(river_group) |> 
  summarize(min_flow_cfs = min(flow_cfs), max_flow_cfs = max(flow_cfs))

mainstems_comid |> 
  st_zm() |> 
  filter(comid %in% mainstems_comid$comid) |>
  ggplot() + 
  geom_sf(aes(color=river_group)) + 
  theme(legend.key.height = unit(12, "point"))

dsm_habitat_combined <-
  dsm_habitat_instream |>
  filter(hab %in% c("spawn", "juv")) |>
  full_join(dsm_habitat_floodplain |>
              select(river_group, hab, run, flow_cfs, suitable_ac = floodplain_acres_suitable),
            by = join_by(river_group, hab, run, flow_cfs)) |>
  inner_join(mainstems |> 
               mutate(length_ft = st_length(geometry) |> units::set_units("ft") |> units::drop_units()) |>
               group_by(watershed) |> 
               summarize(length_ft = sum(length_ft)) |>
               st_drop_geometry(),
             by=join_by(river_group == watershed)) |>
  arrange(river_group, hab, run, flow_cfs) |>
  group_by(river_group, hab, run) |>
  mutate(wua_per_lf = zoo::na.approx(wua_per_lf, x = flow_cfs, na.rm=F),
         suitable_ac = zoo::na.approx(suitable_ac, x = flow_cfs, na.rm=F))|>
  mutate(suitable_ac = if_else(hab == "floodplain", 
                               suitable_ac, 
                               (wua_per_lf * length_ft / 43560)),
         wua_per_lf = if_else(hab == "floodplain", 
                               (suitable_ac * 43560 / length_ft),
                               wua_per_lf)) |>
  mutate(regional_approx = 
           ((hab == "floodplain") & ((river_group %in% c(deer_creek_fp_proxy, cottonwood_creek_fp_proxy)))) |
           ((hab != "floodplain") & ((river_group %in% c(regional_approx_groups)))))|>
  mutate(hab_type = case_when(hab == "juv" ~ "rearing",
                              hab == "spawn" ~ "spawning",
                              hab == "floodplain" ~ "rearing"),
         hab_subtype = case_when(hab == "juv" ~ "instream",
                                 hab == "spawn" ~ "instream",
                                 hab == "floodplain" ~ "floodplain"))
```

```{r pred-watersheds-dsmhabitat-comparison, fig.width=8.5, fig.height=8.5, dpi=300}
wua_predicted_cv_mainstems_grouped |>
  filter(habitat == "rearing") |>
  filter(river_group %in% dsm_habitat_combined$river_group) |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_group, scales="free") + 
  geom_ribbon(aes(ymin = wua_acres_pred_SD, ymax = wua_acres_pred_SN, 
                  fill = paste("habistat", habitat)), alpha=0.33) +
  geom_line(aes(y = wua_acres_pred, color = paste("habistat", habitat))) +
  scale_x_log10() +
  geom_line(data=dsm_habitat_combined |>
              filter(run == "fall") |>
              filter(hab_type == "rearing") |>
              filter(flow_cfs <= 15000), 
            aes(x = flow_cfs, y = suitable_ac, color = paste("DSMhabitat", hab_subtype), linetype = regional_approx)) +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(name = "Habitat Data Source", palette = "Dark2", aesthetics = c("color", "fill")) +
  scale_linetype_manual(name = "Regional Approx.", values = c("TRUE" = "dashed", "FALSE" = "solid")) +
  ylab("Predicted Total Habitat (acres)") + xlab("Flow at Outlet (cfs)") + 
    guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2)) +
  ggtitle("Rearing Comparison - Total Acres")

wua_predicted_cv_mainstems_grouped |>
  filter(habitat == "spawning") |>
  filter(river_group %in% dsm_habitat_combined$river_group) |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_group, scales="free") + 
  geom_ribbon(aes(ymin = wua_acres_pred_SD, ymax = wua_acres_pred_SN, 
                  fill = paste("habistat", habitat)), alpha=0.33) +
  geom_line(aes(y = wua_acres_pred, color = paste("habistat", habitat))) +
  scale_x_log10() +
  geom_line(data=dsm_habitat_combined |>
              filter(run == "fall") |>
              filter(hab_type == "spawning") |>
              filter(flow_cfs <= 15000), 
            aes(x = flow_cfs, y = suitable_ac, color = paste("DSMhabitat", "spawning"), linetype = regional_approx)) +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(name = "Habitat Data Source", palette = "Dark2", aesthetics = c("color", "fill")) +
  scale_linetype_manual(name = "Regional Approx.", values = c("TRUE" = "dashed", "FALSE" = "solid")) +
  ylab("Predicted Total Habitat (acres)") + xlab("Flow at Outlet (cfs)") + 
    guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2)) +
  ggtitle("Spawning Comparison - Total Acres")

wua_predicted_cv_mainstems_grouped |>
  filter(habitat == "rearing") |>
  filter(river_group %in% dsm_habitat_combined$river_group) |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_group, scales="free") + 
  geom_ribbon(aes(ymin = wua_per_lf_pred_SD, ymax = wua_per_lf_pred_SN, 
                  fill = paste("habistat", habitat)), alpha=0.33) +
  geom_line(aes(y = wua_per_lf_pred, color = paste("habistat", habitat))) +
  scale_x_log10() +
  geom_line(data=dsm_habitat_combined |>
              filter(run == "fall") |>
              filter(hab_type == "rearing") |>
              filter(flow_cfs <= 15000), 
            aes(x = flow_cfs, y = wua_per_lf, color = paste("DSMhabitat", hab_subtype), linetype = regional_approx)) +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(name = "Habitat Data Source", palette = "Dark2", aesthetics = c("color", "fill")) +
  scale_linetype_manual(name = "Regional Approx.", values = c("TRUE" = "dashed", "FALSE" = "solid")) +
  ylab("Predicted Habitat (ft2) per LF") + xlab("Flow at Outlet (cfs)") + 
    guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2)) +
  ggtitle("Rearing Comparison - Suitable Area per Linear Ft")

wua_predicted_cv_mainstems_grouped |>
  filter(habitat == "spawning") |>
  filter(river_group %in% dsm_habitat_combined$river_group) |>
  ggplot(aes(x = flow_cfs)) + 
  facet_wrap(~river_group, scales="free") + 
  geom_ribbon(aes(ymin = wua_per_lf_pred_SD, ymax = wua_per_lf_pred_SN, 
                  fill = paste("habistat", habitat)), alpha=0.33) +
  geom_line(aes(y = wua_per_lf_pred, color = paste("habistat", habitat))) +
  scale_x_log10() +
  geom_line(data=dsm_habitat_combined |>
              filter(run == "fall") |>
              filter(hab_type == "spawning") |>
              filter(flow_cfs <= 15000), 
            aes(x = flow_cfs, y = wua_per_lf, color = paste("DSMhabitat", "spawning"), linetype = regional_approx)) +
  theme(legend.position = "top", panel.grid.minor = element_blank()) + 
  scale_color_brewer(name = "Habitat Data Source", palette = "Dark2", aesthetics = c("color", "fill")) +
  scale_linetype_manual(name = "Regional Approx.", values = c("TRUE" = "dashed", "FALSE" = "solid")) +
  ylab("Predicted Habitat (ft2) per LF") + xlab("Flow at Outlet (cfs)") + 
    guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2)) +
  ggtitle("Spawning Comparison - Suitable Area per Linear Ft")
```

```{r}
knitr::knit_exit()
```

## Applying this method to the duration analyis

* Associate each streamgage with a COMID, drainage area, and DA precipitation
* When doing COMID scale duration analysis, use these values to scale the x axis of the inundation curve directly
* When doing watershed scale duration analysis
  - pick a streamgage
  - for each selected comid, 
    - create a flow-to-suitable-area curve along downscaled flows using complete-approx method (above)
    - make a flow-scaled version of the gage's inundation curve
    - apply the flow-scaled inundation curve to the flow-scaled habitat curve
  - consolidate and sum the result curves
  
Below was development of the method implemented in the Shiny app and in the `habitat_` functions.

### Streamgage drainage area attributes

```{r}
streamgage_da_attr <-
  habistat::cv_mainstems |>
  nest(stem_ln_geom = c(comid, habitat, geometry), .by = c(river_group, river_cvpia)) |>
  inner_join(habistat::streamgage_attr, by=join_by(river_group, river_cvpia)) |>
  inner_join(x=habistat::streamgage_geom |> nest(gage_pt_geom = c(geometry)), 
             y=_, 
             by=join_by(station_id)) |>
  mutate(gage_comid = map2_int(gage_pt_geom, stem_ln_geom,
                               function(gage_pt, stem_ln) stem_ln$comid[[st_nearest_feature(gage_pt, stem_ln)]])) |>
  select(station_id, gage_comid) |>
  inner_join(habistat::flowline_attr |>
              select(gage_comid = comid,
                     da_gage = da_area_sq_km,
                     pc_gage = da_ppt_mean_mm), 
             by=join_by(gage_comid)) |>
  glimpse()

streamgage_da_attr |> usethis::use_data(overwrite = T)
```
### Example application to COMID-level flow-to-suitable-area curve

```{r}
selected_comid <- 8020536  
selected_gage <- "dcv"
selected_habitat <- "rearing"
selected_run <- "fall"
selected_wy_type <- "Dry"

fsa <-
  habistat::wua_predicted |>
  filter((habitat == selected_habitat) &
           (comid == selected_comid)) |>
  glimpse()

selected_comid_attr <- 
  habistat::flowline_attr |>
  filter(comid == selected_comid) |>
  as.list()

drc <-
  habistat::streamgage_duration_rating_curves |>
  filter((station_id == selected_gage) & 
           (habitat == selected_habitat) & 
           (run == selected_run) & 
           (wy_group == selected_wy_type)) |>
  unnest(data) 

drc_scaled <- drc |>
  inner_join(streamgage_da_attr, by=join_by(station_id)) |>
  mutate(model_q = model_q * (selected_comid_attr$da_area_sq_km_tot / da_gage) * (selected_comid_attr$da_ppt_mean_mm / pc_gage)) |>
  glimpse()

habistat::duration_apply_dhsi_to_fsa_curve(
        fsa = fsa,
        fsa_q = flow_cfs,
        fsa_wua = wua_per_lf_pred,
        drc = drc_scaled,
        drc_q = model_q,
        drc_dhsi = durhsi_rearing_vf) |>
        glimpse()
```

### Example application to watershed-level flow-to-suitable-area curve

```{r}
scale_fsa <- function(data, multiplier, .wua_var = wua_per_lf_pred, .flow_var = flow_cfs) {
  data |> 
  expand_grid(scaled = c(FALSE, TRUE)) |>
  mutate({{.flow_var}} := if_else(scaled, {{.flow_var}} * multiplier, {{.flow_var}})) |>
  arrange({{.flow_var}}) |>
  mutate({{.wua_var}} := if_else(scaled, NA, {{.wua_var}})) |>
  mutate({{.wua_var}} := zoo::na.approx({{.wua_var}}, x = {{.flow_var}}, na.rm=F, rule=2)) |>
  filter(scaled) |>
  select(-scaled) |>
  ungroup() 
}
```

```{r example-watershed, fig.width=8.5, fig.height=8.5, dpi=300}
selected_watershed <- "Deer Creek"
selected_gage <- "dcv"
selected_habitat <- "rearing"
selected_run <- "fall"
selected_wy_type <- "Dry"

fsas <-
  habistat::wua_predicted |>
  filter((watershed_level_3 == selected_watershed) &
           (habitat == selected_habitat)) |>
  nest(fsa_raw = c(flow_idx, flow_cfs, reach_length_ft, wua_per_lf_pred)) |>
  inner_join(cv_watersheds_flow_xw, by=join_by(watershed_level_3, comid)) |>
  mutate(fsa_scaled = pmap(list(fsa_raw, multiplier), scale_fsa))

drcs <-
  habistat::streamgage_duration_rating_curves |>
  filter((station_id == selected_gage) & 
           (habitat == selected_habitat) & 
           (run == selected_run) & 
           (wy_group == selected_wy_type)) |>
    rename(drc_raw = data) |>
    inner_join(streamgage_da_attr, by=join_by(station_id)) |>
    expand_grid(comid = fsas$comid) |>
    inner_join(cv_watersheds_flow_xw |> 
                 select(comid, watershed_level_3, da_reach, pc_reach), 
               by=join_by(comid)) |>
    mutate(drc_scaled = 
             pmap(list(drc_raw, da_gage, pc_gage), 
                  function(drc_raw, da_gage, pc_gage) {
                        drc_raw |>
                          mutate(model_q = model_q * 
                                   (da_reach / da_gage) * 
                                   (pc_reach / pc_gage))
                    }))

joined <- inner_join(fsas, drcs, by=join_by(comid, watershed_level_3, habitat, da_reach, pc_reach)) |>
  mutate(result = map2(fsa_scaled, drc_scaled, function(fsa, drc) {
    duration_applied <- 
      habistat::duration_apply_dhsi_to_fsa_curve(
        fsa = fsa,
        fsa_q = flow_cfs,
        fsa_wua = wua_per_lf_pred,
        drc = drc,
        drc_q = model_q,
        drc_dhsi = durhsi_rearing_vf)
    fsa |>
      left_join(duration_applied |> 
                   select(flow_cfs = q, wua_per_lf_pred_dur = durwua),
                 by=join_by(flow_cfs)) |>
      mutate(wua_per_lf_pred_dur = zoo::na.approx(wua_per_lf_pred_dur, x = flow_cfs, na.rm=F, rule=2))
  })) |>
  select(-fsa_raw, -drc_raw, -fsa_scaled, -drc_scaled) |>
  unnest(result)

joined |>
  ggplot(aes(x = flow_cfs)) +
  facet_wrap(~paste0(comid,"\n",round(da_reach), " km2"), scales = "free_x") +
  geom_line(aes(y = wua_per_lf_pred, color = "original")) +
  geom_line(aes(y = wua_per_lf_pred_dur, color = "duration")) +
  theme(panel.grid.minor = element_blank()) +
  xlab("Flow (cfs)") + scale_x_continuous(breaks = scales::breaks_extended(n=3)) + ylab("Suitable Habitat Area (ft2) per LF")
```

```{r example-watershed-summary}
summarized <-
  joined |> 
  group_by(habitat, run, wy_group,
           watershed_level_3, flow_idx) |>
  summarize(wua_per_lf_pred = sum(wua_per_lf_pred * reach_length_ft) / sum(reach_length_ft),
            wua_acres_pred = sum(wua_per_lf_pred * reach_length_ft) / 43560, 
            wua_per_lf_pred_dur = sum(wua_per_lf_pred_dur * reach_length_ft) / sum(reach_length_ft),
            wua_acres_pred_dur = sum(wua_per_lf_pred_dur * reach_length_ft) / 43560, 
            .groups="drop")

summarized |>
  ggplot(aes(x = flow_idx)) +
  geom_line(aes(y = wua_acres_pred, color = "original")) +
  geom_line(aes(y = wua_acres_pred_dur, color = "duration")) +
  ggtitle(glue::glue("{selected_watershed} watershed total calculated using gage {selected_gage}")) +
  scale_x_log10() + theme(panel.grid.minor = element_blank()) +
  xlab("Flow (cfs) at Outlet") + ylab("Suitable Habitat Area (acres)")

```

## Streamgage Crosswalks

See duration_predictions.Rmd for dependencies

```{r}
# requires first running the first part of duration_predictions.Rmd
# in order to download the streamgage time series CSVs to temporary local folder
cdec_filenames <- readRDS(here::here("data-raw", "temp", "cdec_filenames.Rds"))

read_cdec_daily_ts <- function(filename) {
  read_csv(filename, col_types = cols()) |>
    janitor::clean_names() |>
    mutate(value = as.numeric(value)) |>
    filter((value >= 0) & !is.nan(value)) |>
    mutate(obs_date = date(obs_date)) |>
    group_by(obs_date) |>
    summarize(flow_cfs = mean(value, na.rm=T))
}

fit_streamgage_power_series <- function(from_station, to_station) {
  
  ts1 <- 
    filter(cdec_filenames, station_id == from_station)$filename[[1]] |>
    read_cdec_daily_ts() |>
    rename(from_flow = flow_cfs)
  
  ts2 <- 
    filter(cdec_filenames, station_id == to_station)$filename[[1]] |>
    read_cdec_daily_ts() |>
    rename(to_flow = flow_cfs)
  
  ts <- 
    inner_join(ts1, ts2, by=join_by(obs_date)) |>
    filter(from_flow > 0 & to_flow > 0)
  
  if (nrow(ts) >= 365) {
      
    model_fit <- 
      lm(data = ts,
         formula = log(to_flow) ~ log(from_flow))
    
    model_fit_summary <- summary(model_fit)
    
    return(list(
      coeff = exp(model_fit_summary$coefficients[[1, 1]]),
      power = model_fit_summary$coefficients[[2, 1]],
      rsq = model_fit_summary$r.squared,
      n_days = nrow(ts)))
  
  } else {
      
    return(list(
      coeff = NA,
      power = NA,
      rsq = NA,
      n_days = nrow(ts)))

  }
}

if(!file.exists(here::here("data-raw", "results", "streamgage_xw_models.Rds"))) {
  
  streamgage_xw_models <-
    expand_grid(from_station = habistat::streamgage_attr$station_id,
                to_station = habistat::streamgage_attr$station_id) |>
    mutate(result = map2(from_station, to_station, fit_streamgage_power_series)) |>
    unnest_wider(result)
  
  streamgage_xw_models |> saveRDS(here::here("data-raw", "results", "streamgage_xw_models.Rds")) 
  
} else {
  
  streamgage_xw_models <- readRDS(here::here("data-raw", "results", "streamgage_xw_models.Rds"))
  
}
```






